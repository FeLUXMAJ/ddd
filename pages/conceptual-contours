        {
          "title": "Conceptual Contours",
          "story": [
                {
      "type": "paragraph",
      "id": "2227052111977180",
      "text": "Sometimes people chop functionality fine to allow flexible combination. Sometimes they lump it large to encapsulate complexity. Sometimes they seek a consistent granularity, making all classes and operations to a similar scale. These are oversimplifications that don't work well as general rules. But they are motivated by a basic set of problems."
    }
,    {
      "type": "paragraph",
      "id": "4269133637108286",
      "text": "When elements of a model or design are embedded in a monolithic construct, their functionality gets duplicated. The external interface doesn't say everything a client might care about. Their meaning is hard to understand, because different concepts are mixed together."
    }
,    {
      "type": "paragraph",
      "id": "2464369962734829",
      "text": "On the other hand, breaking down classes and methods can pointlessly complicate the client, forcing client objects to understand how tiny pieces fit together. Worse, a concept can be lost completely. Half of a uranium atom is not uranium. And of course, it isn't just grain size that counts, but just where the grain runs."
    }
,    {
      "type": "paragraph",
      "id": "8540678999744073",
      "text": "Therefore:"
    }
,    {
      "type": "paragraph",
      "id": "3099783725823981",
      "text": "Decompose design elements (operations, interfaces, classes, and [[aggregates]]) into cohesive units, taking into consideration your intuition of the important divisions in the domain. Observe the axes of change and stability through successive refactorings and look for the underlying [[conceptual contours]] that explain these shearing patterns. Align the model with the consistent aspects of the domain that make it a viable area of knowledge in the first place."
    }
,    {
      "type": "paragraph",
      "id": "2335177912953548",
      "text": "A supple design based on a deep model yields a simple set of interfaces that combine logically to make sensible statements in the [[ubiquitous language]], and without the distraction and maintenance burden of irrelevant options."
    }

          ]
        }
